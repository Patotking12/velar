import { Clarinet, Tx, types } from 'https://deno.land/x/clarinet@v1.6.0/index.ts';
import { assertEquals } from 'https://deno.land/std@0.90.0/testing/asserts.ts';
import { deployer, addresses, tokens } from './contants.ts';
import { mintToken, createTestPair, checkTupleOk, initRevShare } from './util.ts';
const err_swap_postconditions = 110;
const err_router_preconditions = 200;
const err_router_postconditions = 201;
const { core , token_x , token_y , wstx , lp_token , rev_too ,  } = addresses;
const { token_x_id , token_y_id , lp_token_id ,  } = tokens;
const testPool = [
    types.uint(1),
    types.principal(token_x),
    types.principal(token_y),
    types.principal(lp_token), 
];
// read-only
const addLiquidityCalc = (chain, amt0desired, amt1desired, amt0Min, amt1min)=>chain.callReadOnlyFn('router', 'add-liquidity-calc', [
        types.uint(1),
        types.uint(amt0desired),
        types.uint(amt1desired),
        types.uint(amt0Min),
        types.uint(amt1min), 
    ], deployer);
// public
const addLiquidity = (amt0desired, amt1desired, amt0Min, amt1min, from)=>Tx.contractCall('router', 'add-liquidity', [
        ...testPool,
        types.uint(amt0desired),
        types.uint(amt1desired),
        types.uint(amt0Min),
        types.uint(amt1min), 
    ], from);
const removeLiquidity = (liquidity, amt0Min, amt1min, from)=>Tx.contractCall('router', 'remove-liquidity', [
        ...testPool,
        types.uint(liquidity),
        types.uint(amt0Min),
        types.uint(amt1min), 
    ], from);
const swapExactTokensForTokens = (tokenIn, tokenOut, amtIn, amtOutMin, from)=>Tx.contractCall('router', 'swap-exact-tokens-for-tokens', [
        types.uint(1),
        types.principal(token_x),
        types.principal(token_y),
        tokenIn === 'x' ? types.principal(token_x) : types.principal(token_y),
        tokenOut === 'x' ? types.principal(token_x) : types.principal(token_y),
        types.principal(rev_too),
        types.uint(amtIn),
        types.uint(amtOutMin), 
    ], from);
const swapTokensForExactTokens = (tokenIn, tokenOut, amtInMax, amtOut, from)=>Tx.contractCall('router', 'swap-tokens-for-exact-tokens', [
        types.uint(1),
        types.principal(token_x),
        types.principal(token_y),
        tokenIn === 'x' ? types.principal(token_x) : types.principal(token_y),
        tokenOut === 'x' ? types.principal(token_x) : types.principal(token_y),
        types.principal(rev_too),
        types.uint(amtInMax),
        types.uint(amtOut), 
    ], from);
// uint: 128 bits (~10**38)
Clarinet.test({
    name: 'add-liquidity-calc : 0 reserves',
    async fn (chain, accounts) {
        const wallet_1 = accounts.get('wallet_1').address;
        // setup
        // reserves 0
        let block = chain.mineBlock([
            mintToken('token-x', 100, wallet_1),
            mintToken('token-y', 100, wallet_1),
            createTestPair(), 
        ]);
        assertEquals(block.receipts.length, 3);
        const tests = [
            [
                [
                    10,
                    10,
                    10,
                    11
                ],
                {
                    amt0: 10,
                    amt1: 10
                }
            ],
            [
                [
                    100,
                    100,
                    200,
                    200
                ],
                {
                    amt0: 100,
                    amt1: 100
                }
            ], 
        ];
        const res = tests.map(([inputs])=>addLiquidityCalc(chain, ...inputs));
        tests.map(([, exp], i)=>checkTupleOk(res[i], exp));
    }
});
Clarinet.test({
    name: 'add-liquidity : fails on min > desired',
    async fn (chain, accounts) {
        const wallet_1 = accounts.get('wallet_1').address;
        // setup
        let block = chain.mineBlock([
            mintToken('token-x', 1_000_000, wallet_1),
            mintToken('token-y', 1_000_000, wallet_1),
            createTestPair(), 
        ]);
        assertEquals(block.receipts.length, 3);
        // test
        block = chain.mineBlock([
            addLiquidity(10, 12, 10, 100, wallet_1)
        ]);
        block.receipts[0].result.expectErr(err_router_preconditions);
    }
});
Clarinet.test({
    name: 'add-liquidity : returns same value with equal pool',
    async fn (chain, accounts) {
        const wallet_1 = accounts.get('wallet_1').address;
        // setup
        let block = chain.mineBlock([
            mintToken('token-x', 10_000_000, wallet_1),
            mintToken('token-y', 10_000_000, wallet_1),
            createTestPair(),
            addLiquidity(1_000_000, 1_000_000, 1_000_000, 1_000_000, wallet_1), 
        ]);
        assertEquals(block.receipts.length, 4);
        // amt-desired/amt-min
        const tests = [
            [
                [
                    100,
                    100,
                    80,
                    80,
                    wallet_1
                ],
                {
                    amt0: 100,
                    amt1: 100
                }
            ],
            [
                [
                    1_000,
                    1_000,
                    800,
                    1_000,
                    wallet_1
                ],
                {
                    amt0: 1_000,
                    amt1: 1_000
                }
            ],
            [
                [
                    10_000,
                    10_000,
                    8_000,
                    10_000,
                    wallet_1
                ],
                {
                    amt0: 10_000,
                    amt1: 10_000
                }
            ], 
        ];
        block = chain.mineBlock(tests.map(([inputs])=>addLiquidity(...inputs)));
        tests.map(([, exp], i)=>checkTupleOk(block.receipts[i], exp));
    }
});
Clarinet.test({
    name: 'add-liquidity : unequal pool',
    async fn (chain, accounts) {
        const wallet_1 = accounts.get('wallet_1').address;
        // setup
        let block = chain.mineBlock([
            mintToken('token-x', 10_000_000, wallet_1),
            mintToken('token-y', 10_000_000, wallet_1),
            createTestPair(),
            addLiquidity(1_000_000, 5_000_000, 1_000_000, 5_000_000, wallet_1)
        ]);
        assertEquals(block.receipts.length, 4);
        // amt-desired/amt-min
        const tests = [
            [
                [
                    100,
                    100,
                    20,
                    80,
                    wallet_1
                ],
                {
                    amt0: 20,
                    amt1: 100
                }
            ],
            [
                [
                    1_000,
                    1_000,
                    200,
                    1_000,
                    wallet_1
                ],
                {
                    amt0: 200,
                    amt1: 1_000
                }
            ],
            [
                [
                    10_000,
                    10_000,
                    2_000,
                    10_000,
                    wallet_1
                ],
                {
                    amt0: 2_000,
                    amt1: 10_000
                }
            ], 
        ];
        block = chain.mineBlock(tests.map(([inputs])=>addLiquidity(...inputs)));
        tests.map(([, exp], i)=>checkTupleOk(block.receipts[i], exp));
    }
});
Clarinet.test({
    name: 'removeLiquidity',
    async fn (chain, accounts) {
        const wallet_1 = accounts.get('wallet_1').address;
        // setup
        let block = chain.mineBlock([
            mintToken('token-x', 1_000_000, wallet_1),
            mintToken('token-y', 1_000_000, wallet_1),
            createTestPair(),
            addLiquidity(1_000, 1_000, 1_000, 1_000, wallet_1), 
        ]);
        assertEquals(block.receipts.length, 4);
        let assets = chain.getAssetsMaps().assets;
        // liquidity, amts-min
        block = chain.mineBlock([
            removeLiquidity(1_000, 1_000, 1_000, wallet_1),
            addLiquidity(1_000, 1_000, 1_000, 1_000, wallet_1), 
        ]);
        checkTupleOk(block.receipts[0], {
            amt0: 1_000,
            amt1: 1_000
        });
        const tests = [
            [
                [
                    10,
                    10,
                    10,
                    wallet_1
                ],
                {
                    amt0: 10,
                    amt1: 10
                }
            ],
            [
                [
                    20,
                    20,
                    20,
                    wallet_1
                ],
                {
                    amt0: 20,
                    amt1: 20
                }
            ],
            [
                [
                    100,
                    10,
                    10,
                    wallet_1
                ],
                {
                    amt0: 100,
                    amt1: 100
                }
            ], 
        ];
        block = chain.mineBlock(tests.map(([inputs])=>removeLiquidity(...inputs)));
        assets = chain.getAssetsMaps().assets;
        tests.map(([, exp], i)=>checkTupleOk(block.receipts[i], exp));
    }
});
Clarinet.test({
    name: 'swap-exact-tokens-for-tokens ....',
    async fn (chain, accounts) {
        const wallet_1 = accounts.get('wallet_1').address;
        const wallet_2 = accounts.get('wallet_2').address;
        // setup
        initRevShare(chain);
        let block = chain.mineBlock([
            mintToken('token-x', 1_000_000, wallet_1),
            mintToken('token-y', 1_000_000, wallet_1),
            mintToken('token-x', 1_000_000, wallet_2),
            createTestPair(),
            addLiquidity(1_000, 500, 1_000, 500, wallet_1), 
        ]);
        let assets = chain.getAssetsMaps().assets;
        // tokenOut, tokenOut, in, minOut
        block = chain.mineBlock([
            swapExactTokensForTokens('x', 'y', 500, 1, wallet_2)
        ]);
        assets = chain.getAssetsMaps().assets;
        assertEquals(assets[token_x_id][wallet_1], 1_000_000 - 1_000);
        assertEquals(assets[token_y_id][wallet_1], 1_000_000 - 500);
        assertEquals(assets[token_x_id][wallet_2], 1_000_000 - 500);
        assertEquals(assets[token_y_id][wallet_2], 166);
        assertEquals(assets[token_x_id][core], 1_500);
        assertEquals(assets[token_y_id][core], 500 - 166);
        block = chain.mineBlock([
            swapExactTokensForTokens('y', 'x', 166, 400, wallet_2)
        ]);
        assets = chain.getAssetsMaps().assets;
        assertEquals(assets[token_x_id][wallet_2], 1_000_000 - 500 + 495);
        assertEquals(assets[token_y_id][wallet_2], 0);
        assertEquals(assets[token_x_id][core], 1_500 - 495);
        assertEquals(assets[token_y_id][core], 500);
    }
});
Clarinet.test({
    name: 'swap-tokens-for-exact-tokens ....',
    async fn (chain, accounts) {
        const wallet_1 = accounts.get('wallet_1').address;
        const wallet_2 = accounts.get('wallet_2').address;
        // setup
        initRevShare(chain);
        let block = chain.mineBlock([
            mintToken('token-x', 1_000_000, wallet_1),
            mintToken('token-y', 1_000_000, wallet_1),
            mintToken('token-x', 1_000_000, wallet_2),
            createTestPair(),
            addLiquidity(1_000, 500, 1_000, 500, wallet_1), 
        ]);
        let assets = chain.getAssetsMaps().assets;
        // tokenIn, tokenOut, maxIn, out
        // NOTE: division by zero error when swapping out all
        block = chain.mineBlock([
            swapTokensForExactTokens('x', 'y', 1_000, 10, wallet_2), 
        ]);
        // TODO: check wrong token-0/token-1
        assets = chain.getAssetsMaps().assets;
        block.receipts[0].result.expectErr().expectUint(err_swap_postconditions);
    }
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vVXNlcnMvUGF0b19Hb21lei9EZXNrdG9wL1ZlbGFyL3ZlbGFyL3Rlc3RzL3JvdXRlcl90ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IHsgQ2xhcmluZXQsIFR4LCBDaGFpbiwgQWNjb3VudCwgdHlwZXMsIEVtcHR5QmxvY2sgfSBmcm9tICdodHRwczovL2Rlbm8ubGFuZC94L2NsYXJpbmV0QHYxLjYuMC9pbmRleC50cyc7XG5pbXBvcnQgeyBhc3NlcnRFcXVhbHMgfSBmcm9tICdodHRwczovL2Rlbm8ubGFuZC9zdGRAMC45MC4wL3Rlc3RpbmcvYXNzZXJ0cy50cyc7XG5pbXBvcnQgeyBkZXBsb3llciwgYWRkcmVzc2VzLCB0b2tlbnMgfSBmcm9tICcuL2NvbnRhbnRzLnRzJztcbmltcG9ydCB7XG4gIG1pbnRUb2tlbixcbiAgY3JlYXRlVGVzdFBhaXIsXG4gIGNoZWNrVHVwbGUsXG4gIGNyZWF0ZVdTVFhQYWlyLFxuICBjaGVja1R1cGxlUmVzdWx0LFxuICBjaGVja1R1cGxlT2ssXG4gIGluaXRSZXZTaGFyZSxcbn0gZnJvbSAnLi91dGlsLnRzJztcblxudHlwZSBCaWcgPSBudW1iZXJ8c3RyaW5nXG5cbmNvbnN0IGVycl9zd2FwX3Bvc3Rjb25kaXRpb25zICAgPSAxMTBcblxuY29uc3QgZXJyX3JvdXRlcl9wcmVjb25kaXRpb25zICA9IDIwMFxuY29uc3QgZXJyX3JvdXRlcl9wb3N0Y29uZGl0aW9ucyA9IDIwMVxuXG5jb25zdCB7IFxuICBjb3JlLFxuICB0b2tlbl94LFxuICB0b2tlbl95LFxuICB3c3R4LFxuICBscF90b2tlbixcbiAgcmV2X3Rvbyxcbn0gPSBhZGRyZXNzZXNcblxuY29uc3Qge1xuICB0b2tlbl94X2lkLFxuICB0b2tlbl95X2lkLFxuICBscF90b2tlbl9pZCxcbn0gPSB0b2tlbnNcblxuY29uc3QgdGVzdFBvb2wgPSBbXG4gIHR5cGVzLnVpbnQoMSksXG4gIHR5cGVzLnByaW5jaXBhbCh0b2tlbl94KSxcbiAgdHlwZXMucHJpbmNpcGFsKHRva2VuX3kpLFxuICB0eXBlcy5wcmluY2lwYWwobHBfdG9rZW4pLFxuXVxuXG4vLyByZWFkLW9ubHlcbmNvbnN0IGFkZExpcXVpZGl0eUNhbGMgPSAoY2hhaW46IENoYWluLCBhbXQwZGVzaXJlZDogQmlnLCBhbXQxZGVzaXJlZDogQmlnLCBhbXQwTWluOiBCaWcsIGFtdDFtaW46IEJpZykgPT5cbiAgICBjaGFpbi5jYWxsUmVhZE9ubHlGbigncm91dGVyJywgJ2FkZC1saXF1aWRpdHktY2FsYycsIFtcbiAgICAgICAgdHlwZXMudWludCgxKSxcbiAgICAgICAgdHlwZXMudWludChhbXQwZGVzaXJlZCksXG4gICAgICAgIHR5cGVzLnVpbnQoYW10MWRlc2lyZWQpLFxuICAgICAgICB0eXBlcy51aW50KGFtdDBNaW4pLFxuICAgICAgICB0eXBlcy51aW50KGFtdDFtaW4pLFxuICAgIF0sIGRlcGxveWVyKVxuXG4vLyBwdWJsaWNcbmNvbnN0IGFkZExpcXVpZGl0eSA9IChhbXQwZGVzaXJlZDogQmlnLCBhbXQxZGVzaXJlZDogQmlnLCBhbXQwTWluOiBCaWcsIGFtdDFtaW46IEJpZywgZnJvbTogc3RyaW5nKSA9PlxuICAgIFR4LmNvbnRyYWN0Q2FsbCgncm91dGVyJywgJ2FkZC1saXF1aWRpdHknLCBbXG4gICAgICAgIC4uLnRlc3RQb29sLFxuICAgICAgICB0eXBlcy51aW50KGFtdDBkZXNpcmVkKSxcbiAgICAgICAgdHlwZXMudWludChhbXQxZGVzaXJlZCksXG4gICAgICAgIHR5cGVzLnVpbnQoYW10ME1pbiksXG4gICAgICAgIHR5cGVzLnVpbnQoYW10MW1pbiksXG4gICAgXSwgZnJvbSlcblxuY29uc3QgcmVtb3ZlTGlxdWlkaXR5ID0gKGxpcXVpZGl0eTogQmlnLCBhbXQwTWluOiBCaWcsIGFtdDFtaW46IEJpZywgZnJvbTogc3RyaW5nKSA9PlxuICAgIFR4LmNvbnRyYWN0Q2FsbCgncm91dGVyJywgJ3JlbW92ZS1saXF1aWRpdHknLCBbXG4gICAgICAgIC4uLnRlc3RQb29sLFxuICAgICAgICB0eXBlcy51aW50KGxpcXVpZGl0eSksXG4gICAgICAgIHR5cGVzLnVpbnQoYW10ME1pbiksXG4gICAgICAgIHR5cGVzLnVpbnQoYW10MW1pbiksXG4gICAgXSwgZnJvbSlcblxuY29uc3Qgc3dhcEV4YWN0VG9rZW5zRm9yVG9rZW5zID0gKHRva2VuSW46ICd4J3wneScsIHRva2VuT3V0OiAneCd8J3knLCBhbXRJbjogQmlnLCBhbXRPdXRNaW46IEJpZywgZnJvbTogc3RyaW5nKSA9PlxuICAgIFR4LmNvbnRyYWN0Q2FsbCgncm91dGVyJywgJ3N3YXAtZXhhY3QtdG9rZW5zLWZvci10b2tlbnMnLCBbXG4gICAgICAgIHR5cGVzLnVpbnQoMSksXG4gICAgICAgIHR5cGVzLnByaW5jaXBhbCh0b2tlbl94KSxcbiAgICAgICAgdHlwZXMucHJpbmNpcGFsKHRva2VuX3kpLFxuICAgICAgICB0b2tlbkluID09PSAneCcgPyB0eXBlcy5wcmluY2lwYWwodG9rZW5feCk6IHR5cGVzLnByaW5jaXBhbCh0b2tlbl95KSxcbiAgICAgICAgdG9rZW5PdXQgPT09ICd4JyA/IHR5cGVzLnByaW5jaXBhbCh0b2tlbl94KTogdHlwZXMucHJpbmNpcGFsKHRva2VuX3kpLFxuICAgICAgICB0eXBlcy5wcmluY2lwYWwocmV2X3RvbyksXG4gICAgICAgIHR5cGVzLnVpbnQoYW10SW4pLFxuICAgICAgICB0eXBlcy51aW50KGFtdE91dE1pbiksXG4gICAgXSwgZnJvbSlcblxuY29uc3Qgc3dhcFRva2Vuc0ZvckV4YWN0VG9rZW5zID0gKHRva2VuSW46ICd4J3wneScsIHRva2VuT3V0OiAneCd8J3knLCBhbXRJbk1heDogQmlnLCBhbXRPdXQ6IEJpZywgZnJvbTogc3RyaW5nKSA9PlxuICAgIFR4LmNvbnRyYWN0Q2FsbCgncm91dGVyJywgJ3N3YXAtdG9rZW5zLWZvci1leGFjdC10b2tlbnMnLCBbXG4gICAgICAgIHR5cGVzLnVpbnQoMSksXG4gICAgICAgIHR5cGVzLnByaW5jaXBhbCh0b2tlbl94KSxcbiAgICAgICAgdHlwZXMucHJpbmNpcGFsKHRva2VuX3kpLFxuICAgICAgICB0b2tlbkluID09PSAneCcgPyB0eXBlcy5wcmluY2lwYWwodG9rZW5feCk6IHR5cGVzLnByaW5jaXBhbCh0b2tlbl95KSxcbiAgICAgICAgdG9rZW5PdXQgPT09ICd4JyA/IHR5cGVzLnByaW5jaXBhbCh0b2tlbl94KTogdHlwZXMucHJpbmNpcGFsKHRva2VuX3kpLFxuICAgICAgICB0eXBlcy5wcmluY2lwYWwocmV2X3RvbyksXG4gICAgICAgIHR5cGVzLnVpbnQoYW10SW5NYXgpLFxuICAgICAgICB0eXBlcy51aW50KGFtdE91dCksXG4gICAgXSwgZnJvbSlcblxuLy8gdWludDogMTI4IGJpdHMgKH4xMCoqMzgpXG5cbkNsYXJpbmV0LnRlc3Qoe1xuICAgIG5hbWU6ICdhZGQtbGlxdWlkaXR5LWNhbGMgOiAwIHJlc2VydmVzJyxcbiAgICBhc3luYyBmbihjaGFpbjogQ2hhaW4sIGFjY291bnRzOiBNYXA8c3RyaW5nLCBBY2NvdW50Pikge1xuICAgICAgY29uc3Qgd2FsbGV0XzEgPSBhY2NvdW50cy5nZXQoJ3dhbGxldF8xJykhLmFkZHJlc3NcblxuICAgICAgLy8gc2V0dXBcbiAgICAgIC8vIHJlc2VydmVzIDBcbiAgICAgIGxldCBibG9jayA9IGNoYWluLm1pbmVCbG9jayhbXG4gICAgICAgICAgbWludFRva2VuKCd0b2tlbi14JywgMTAwLCB3YWxsZXRfMSksXG4gICAgICAgICAgbWludFRva2VuKCd0b2tlbi15JywgMTAwLCB3YWxsZXRfMSksXG4gICAgICAgICAgY3JlYXRlVGVzdFBhaXIoKSxcbiAgICAgIF0pXG5cbiAgICAgIGFzc2VydEVxdWFscyhibG9jay5yZWNlaXB0cy5sZW5ndGgsIDMpXG5cbiAgICAgIGNvbnN0IHRlc3RzID0gW1xuICAgICAgICBbWzEwLCAxMCwgMTAsIDExXSwgeyBhbXQwOiAxMCwgYW10MTogMTB9XSxcbiAgICAgICAgW1sxMDAsIDEwMCwgMjAwLCAyMDBdLCB7IGFtdDA6IDEwMCwgYW10MTogMTAwfV0sXG4gICAgICBdXG5cbiAgICAgIGNvbnN0IHJlcyA9IHRlc3RzLm1hcCgoW2lucHV0c10pID0+IGFkZExpcXVpZGl0eUNhbGMoY2hhaW4sIC4uLmlucHV0cykpXG4gICAgICB0ZXN0cy5tYXAoKFssIGV4cF0sIGkpID0+IGNoZWNrVHVwbGVPayhyZXNbaV0sIGV4cCkpXG4gICAgfVxufSlcblxuQ2xhcmluZXQudGVzdCh7XG4gIG5hbWU6ICdhZGQtbGlxdWlkaXR5IDogZmFpbHMgb24gbWluID4gZGVzaXJlZCcsXG4gIGFzeW5jIGZuKGNoYWluOiBDaGFpbiwgYWNjb3VudHM6IE1hcDxzdHJpbmcsIEFjY291bnQ+KSB7XG4gICAgY29uc3Qgd2FsbGV0XzEgPSBhY2NvdW50cy5nZXQoJ3dhbGxldF8xJykhLmFkZHJlc3NcblxuICAgIC8vIHNldHVwXG4gICAgbGV0IGJsb2NrID0gY2hhaW4ubWluZUJsb2NrKFtcbiAgICAgICAgbWludFRva2VuKCd0b2tlbi14JywgMV8wMDBfMDAwLCB3YWxsZXRfMSksXG4gICAgICAgIG1pbnRUb2tlbigndG9rZW4teScsIDFfMDAwXzAwMCwgd2FsbGV0XzEpLFxuICAgICAgICBjcmVhdGVUZXN0UGFpcigpLFxuICAgIF0pXG4gICAgYXNzZXJ0RXF1YWxzKGJsb2NrLnJlY2VpcHRzLmxlbmd0aCwgMylcblxuICAgIC8vIHRlc3RcbiAgICBibG9jayA9IGNoYWluLm1pbmVCbG9jayhbXG4gICAgICAgIGFkZExpcXVpZGl0eSgxMCwgMTIsIDEwLCAxMDAsIHdhbGxldF8xKVxuICAgIF0pXG5cbiAgICBibG9jay5yZWNlaXB0c1swXS5yZXN1bHQuZXhwZWN0RXJyKGVycl9yb3V0ZXJfcHJlY29uZGl0aW9ucylcbiAgfVxufSlcblxuQ2xhcmluZXQudGVzdCh7XG4gICAgbmFtZTogJ2FkZC1saXF1aWRpdHkgOiByZXR1cm5zIHNhbWUgdmFsdWUgd2l0aCBlcXVhbCBwb29sJyxcbiAgICBhc3luYyBmbihjaGFpbjogQ2hhaW4sIGFjY291bnRzOiBNYXA8c3RyaW5nLCBBY2NvdW50Pikge1xuICAgICAgICBjb25zdCB3YWxsZXRfMSA9IGFjY291bnRzLmdldCgnd2FsbGV0XzEnKSEuYWRkcmVzc1xuXG4gICAgICAgIC8vIHNldHVwXG4gICAgICAgIGxldCBibG9jayA9IGNoYWluLm1pbmVCbG9jayhbXG4gICAgICAgICAgICBtaW50VG9rZW4oJ3Rva2VuLXgnLCAxMF8wMDBfMDAwLCB3YWxsZXRfMSksXG4gICAgICAgICAgICBtaW50VG9rZW4oJ3Rva2VuLXknLCAxMF8wMDBfMDAwLCB3YWxsZXRfMSksXG4gICAgICAgICAgICBjcmVhdGVUZXN0UGFpcigpLFxuICAgICAgICAgICAgYWRkTGlxdWlkaXR5KDFfMDAwXzAwMCwgMV8wMDBfMDAwLCAxXzAwMF8wMDAsIDFfMDAwXzAwMCwgd2FsbGV0XzEpLFxuICAgICAgICBdKVxuICAgICAgICBhc3NlcnRFcXVhbHMoYmxvY2sucmVjZWlwdHMubGVuZ3RoLCA0KVxuXG4gICAgICAgIC8vIGFtdC1kZXNpcmVkL2FtdC1taW5cbiAgICAgICAgY29uc3QgdGVzdHMgPSBbXG4gICAgICAgICAgICBbWzEwMCwgMTAwLCA4MCwgODAsIHdhbGxldF8xXSwgeyBhbXQwOiAxMDAsIGFtdDE6IDEwMCB9XSxcbiAgICAgICAgICAgIFtbMV8wMDAsIDFfMDAwLCA4MDAsIDFfMDAwLCB3YWxsZXRfMV0sIHsgYW10MDogMV8wMDAsIGFtdDE6IDFfMDAwIH1dLFxuICAgICAgICAgICAgW1sxMF8wMDAsIDEwXzAwMCwgOF8wMDAsIDEwXzAwMCwgd2FsbGV0XzFdLCB7IGFtdDA6IDEwXzAwMCwgYW10MTogMTBfMDAwIH1dLFxuICAgICAgICBdXG5cbiAgICAgICAgYmxvY2sgPSBjaGFpbi5taW5lQmxvY2soXG4gICAgICAgICAgICB0ZXN0cy5tYXAoKFtpbnB1dHNdKSA9PiBhZGRMaXF1aWRpdHkoLi4uaW5wdXRzKSlcbiAgICAgICAgKVxuICAgICAgICB0ZXN0cy5tYXAoKFssIGV4cF0sIGkpID0+IGNoZWNrVHVwbGVPayhibG9jay5yZWNlaXB0c1tpXSwgZXhwKSlcbiAgICB9XG59KVxuXG5DbGFyaW5ldC50ZXN0KHtcbiAgICBuYW1lOiAnYWRkLWxpcXVpZGl0eSA6IHVuZXF1YWwgcG9vbCcsXG4gICAgYXN5bmMgZm4oY2hhaW46IENoYWluLCBhY2NvdW50czogTWFwPHN0cmluZywgQWNjb3VudD4pIHtcbiAgICAgICAgY29uc3Qgd2FsbGV0XzEgPSBhY2NvdW50cy5nZXQoJ3dhbGxldF8xJykhLmFkZHJlc3NcblxuICAgICAgICAvLyBzZXR1cFxuICAgICAgICBsZXQgYmxvY2sgPSBjaGFpbi5taW5lQmxvY2soW1xuICAgICAgICAgICAgbWludFRva2VuKCd0b2tlbi14JywgMTBfMDAwXzAwMCwgd2FsbGV0XzEpLFxuICAgICAgICAgICAgbWludFRva2VuKCd0b2tlbi15JywgMTBfMDAwXzAwMCwgd2FsbGV0XzEpLFxuICAgICAgICAgICAgY3JlYXRlVGVzdFBhaXIoKSxcbiAgICAgICAgICAgIGFkZExpcXVpZGl0eSgxXzAwMF8wMDAsIDVfMDAwXzAwMCwgMV8wMDBfMDAwLCA1XzAwMF8wMDAsIHdhbGxldF8xKVxuICAgICAgICBdKVxuICAgICAgICBhc3NlcnRFcXVhbHMoYmxvY2sucmVjZWlwdHMubGVuZ3RoLCA0KVxuXG4gICAgICAgIC8vIGFtdC1kZXNpcmVkL2FtdC1taW5cbiAgICAgICAgY29uc3QgdGVzdHMgPSBbXG4gICAgICAgICAgICBbWzEwMCwgMTAwLCAyMCwgODAsIHdhbGxldF8xXSwgeyBhbXQwOiAyMCwgYW10MTogMTAwIH1dLFxuICAgICAgICAgICAgW1sxXzAwMCwgMV8wMDAsIDIwMCwgMV8wMDAsIHdhbGxldF8xXSwgeyBhbXQwOiAyMDAsIGFtdDE6IDFfMDAwIH1dLFxuICAgICAgICAgICAgW1sxMF8wMDAsIDEwXzAwMCwgMl8wMDAsIDEwXzAwMCwgd2FsbGV0XzFdLCB7IGFtdDA6IDJfMDAwLCBhbXQxOiAxMF8wMDAgfV0sXG4gICAgICAgIF1cblxuICAgICAgICBibG9jayA9IGNoYWluLm1pbmVCbG9jayhcbiAgICAgICAgICAgIHRlc3RzLm1hcCgoW2lucHV0c10pID0+IGFkZExpcXVpZGl0eSguLi5pbnB1dHMpKVxuICAgICAgICApXG4gICAgICAgIHRlc3RzLm1hcCgoWywgZXhwXSwgaSkgPT4gY2hlY2tUdXBsZU9rKGJsb2NrLnJlY2VpcHRzW2ldLCBleHApKVxuICAgIH1cbn0pXG5cbkNsYXJpbmV0LnRlc3Qoe1xuICBuYW1lOiAncmVtb3ZlTGlxdWlkaXR5JyxcbiAgYXN5bmMgZm4oY2hhaW46IENoYWluLCBhY2NvdW50czogTWFwPHN0cmluZywgQWNjb3VudD4pIHtcbiAgICBjb25zdCB3YWxsZXRfMSA9IGFjY291bnRzLmdldCgnd2FsbGV0XzEnKSEuYWRkcmVzc1xuXG4gICAgLy8gc2V0dXBcbiAgICBsZXQgYmxvY2sgPSBjaGFpbi5taW5lQmxvY2soW1xuICAgICAgICBtaW50VG9rZW4oJ3Rva2VuLXgnLCAxXzAwMF8wMDAsIHdhbGxldF8xKSxcbiAgICAgICAgbWludFRva2VuKCd0b2tlbi15JywgMV8wMDBfMDAwLCB3YWxsZXRfMSksXG4gICAgICAgIGNyZWF0ZVRlc3RQYWlyKCksXG4gICAgICAgIGFkZExpcXVpZGl0eSgxXzAwMCwgMV8wMDAsIDFfMDAwLCAxXzAwMCwgd2FsbGV0XzEpLFxuICAgIF0pXG5cbiAgICBhc3NlcnRFcXVhbHMoYmxvY2sucmVjZWlwdHMubGVuZ3RoLCA0KVxuICAgIGxldCBhc3NldHMgPSBjaGFpbi5nZXRBc3NldHNNYXBzKCkuYXNzZXRzXG5cbiAgICAvLyBsaXF1aWRpdHksIGFtdHMtbWluXG4gICAgYmxvY2sgPSBjaGFpbi5taW5lQmxvY2soW1xuICAgICAgICByZW1vdmVMaXF1aWRpdHkoMV8wMDAsIDFfMDAwLCAxXzAwMCwgd2FsbGV0XzEpLFxuICAgICAgICBhZGRMaXF1aWRpdHkoMV8wMDAsIDFfMDAwLCAxXzAwMCwgMV8wMDAsIHdhbGxldF8xKSxcbiAgICBdKVxuXG4gICAgY2hlY2tUdXBsZU9rKGJsb2NrLnJlY2VpcHRzWzBdLCB7IGFtdDA6IDFfMDAwLCBhbXQxOiAxXzAwMCB9KVxuXG4gICAgY29uc3QgdGVzdHMgPSBbXG4gICAgICAgIFtbMTAsIDEwLCAxMCwgd2FsbGV0XzFdLCB7IGFtdDA6IDEwLCBhbXQxOiAxMCB9XSxcbiAgICAgICAgW1syMCwgMjAsIDIwLCB3YWxsZXRfMV0sIHsgYW10MDogMjAsIGFtdDE6IDIwIH1dLFxuICAgICAgICBbWzEwMCwgMTAsIDEwLCB3YWxsZXRfMV0sIHsgYW10MDogMTAwLCBhbXQxOiAxMDAgfV0sXG4gICAgXVxuXG4gICAgYmxvY2sgPSBjaGFpbi5taW5lQmxvY2soXG4gICAgICAgIHRlc3RzLm1hcCgoW2lucHV0c10pID0+IHJlbW92ZUxpcXVpZGl0eSguLi5pbnB1dHMpKVxuICAgIClcblxuICAgIGFzc2V0cyA9IGNoYWluLmdldEFzc2V0c01hcHMoKS5hc3NldHNcblxuICAgIHRlc3RzLm1hcCgoWywgZXhwXSwgaSkgPT4gY2hlY2tUdXBsZU9rKGJsb2NrLnJlY2VpcHRzW2ldLCBleHApKVxuICB9XG59KVxuXG5DbGFyaW5ldC50ZXN0KHtcbiAgICBuYW1lOiAnc3dhcC1leGFjdC10b2tlbnMtZm9yLXRva2VucyAuLi4uJyxcbiAgICBhc3luYyBmbihjaGFpbjogQ2hhaW4sIGFjY291bnRzOiBNYXA8c3RyaW5nLCBBY2NvdW50Pikge1xuICAgICAgICBjb25zdCB3YWxsZXRfMSA9IGFjY291bnRzLmdldCgnd2FsbGV0XzEnKSEuYWRkcmVzc1xuICAgICAgICBjb25zdCB3YWxsZXRfMiA9IGFjY291bnRzLmdldCgnd2FsbGV0XzInKSEuYWRkcmVzc1xuICAgICAgICBcbiAgICAgICAgLy8gc2V0dXBcbiAgICAgICAgaW5pdFJldlNoYXJlKGNoYWluKVxuXG4gICAgICAgIGxldCBibG9jayA9IGNoYWluLm1pbmVCbG9jayhbXG4gICAgICAgICAgICBtaW50VG9rZW4oJ3Rva2VuLXgnLCAxXzAwMF8wMDAsIHdhbGxldF8xKSxcbiAgICAgICAgICAgIG1pbnRUb2tlbigndG9rZW4teScsIDFfMDAwXzAwMCwgd2FsbGV0XzEpLFxuICAgICAgICAgICAgbWludFRva2VuKCd0b2tlbi14JywgMV8wMDBfMDAwLCB3YWxsZXRfMiksXG4gICAgICAgICAgICBjcmVhdGVUZXN0UGFpcigpLFxuICAgICAgICAgICAgYWRkTGlxdWlkaXR5KDFfMDAwLCA1MDAsIDFfMDAwLCA1MDAsIHdhbGxldF8xKSxcbiAgICAgICAgXSlcbiAgICBcbiAgICAgICAgbGV0IGFzc2V0cyA9IGNoYWluLmdldEFzc2V0c01hcHMoKS5hc3NldHNcblxuICAgICAgICAvLyB0b2tlbk91dCwgdG9rZW5PdXQsIGluLCBtaW5PdXRcbiAgICAgICAgYmxvY2sgPSBjaGFpbi5taW5lQmxvY2soW1xuICAgICAgICAgICAgc3dhcEV4YWN0VG9rZW5zRm9yVG9rZW5zKCd4JywgJ3knLCA1MDAsIDEsIHdhbGxldF8yKVxuICAgICAgICBdKVxuXG4gICAgICAgIGFzc2V0cyA9IGNoYWluLmdldEFzc2V0c01hcHMoKS5hc3NldHNcbiAgICAgICAgYXNzZXJ0RXF1YWxzKGFzc2V0c1t0b2tlbl94X2lkXVt3YWxsZXRfMV0sIDFfMDAwXzAwMCAtIDFfMDAwKVxuICAgICAgICBhc3NlcnRFcXVhbHMoYXNzZXRzW3Rva2VuX3lfaWRdW3dhbGxldF8xXSwgMV8wMDBfMDAwIC0gNTAwKVxuICAgICAgICBhc3NlcnRFcXVhbHMoYXNzZXRzW3Rva2VuX3hfaWRdW3dhbGxldF8yXSwgMV8wMDBfMDAwIC0gNTAwKVxuICAgICAgICBhc3NlcnRFcXVhbHMoYXNzZXRzW3Rva2VuX3lfaWRdW3dhbGxldF8yXSwgMTY2KVxuICAgICAgICBhc3NlcnRFcXVhbHMoYXNzZXRzW3Rva2VuX3hfaWRdW2NvcmVdLCAxXzUwMClcbiAgICAgICAgYXNzZXJ0RXF1YWxzKGFzc2V0c1t0b2tlbl95X2lkXVtjb3JlXSwgNTAwIC0gMTY2KVxuXG4gICAgICAgIGJsb2NrID0gY2hhaW4ubWluZUJsb2NrKFtcbiAgICAgICAgICAgIHN3YXBFeGFjdFRva2Vuc0ZvclRva2VucygneScsICd4JywgMTY2LCA0MDAsIHdhbGxldF8yKVxuICAgICAgICBdKVxuXG4gICAgICAgIGFzc2V0cyA9IGNoYWluLmdldEFzc2V0c01hcHMoKS5hc3NldHNcbiAgICAgICAgYXNzZXJ0RXF1YWxzKGFzc2V0c1t0b2tlbl94X2lkXVt3YWxsZXRfMl0sIDFfMDAwXzAwMCAtIDUwMCArIDQ5NSlcbiAgICAgICAgYXNzZXJ0RXF1YWxzKGFzc2V0c1t0b2tlbl95X2lkXVt3YWxsZXRfMl0sIDApXG4gICAgICAgIGFzc2VydEVxdWFscyhhc3NldHNbdG9rZW5feF9pZF1bY29yZV0sIDFfNTAwIC0gNDk1KVxuICAgICAgICBhc3NlcnRFcXVhbHMoYXNzZXRzW3Rva2VuX3lfaWRdW2NvcmVdLCA1MDApXG4gICAgfVxufSlcblxuQ2xhcmluZXQudGVzdCh7XG4gICAgbmFtZTogJ3N3YXAtdG9rZW5zLWZvci1leGFjdC10b2tlbnMgLi4uLicsXG4gICAgYXN5bmMgZm4oY2hhaW46IENoYWluLCBhY2NvdW50czogTWFwPHN0cmluZywgQWNjb3VudD4pIHtcbiAgICAgICAgY29uc3Qgd2FsbGV0XzEgPSBhY2NvdW50cy5nZXQoJ3dhbGxldF8xJykhLmFkZHJlc3NcbiAgICAgICAgY29uc3Qgd2FsbGV0XzIgPSBhY2NvdW50cy5nZXQoJ3dhbGxldF8yJykhLmFkZHJlc3NcbiAgICAgICAgXG4gICAgICAgIC8vIHNldHVwXG4gICAgICAgIGluaXRSZXZTaGFyZShjaGFpbilcblxuICAgICAgICBsZXQgYmxvY2sgPSBjaGFpbi5taW5lQmxvY2soW1xuICAgICAgICAgICAgbWludFRva2VuKCd0b2tlbi14JywgMV8wMDBfMDAwLCB3YWxsZXRfMSksXG4gICAgICAgICAgICBtaW50VG9rZW4oJ3Rva2VuLXknLCAxXzAwMF8wMDAsIHdhbGxldF8xKSxcbiAgICAgICAgICAgIG1pbnRUb2tlbigndG9rZW4teCcsIDFfMDAwXzAwMCwgd2FsbGV0XzIpLFxuICAgICAgICAgICAgY3JlYXRlVGVzdFBhaXIoKSxcbiAgICAgICAgICAgIGFkZExpcXVpZGl0eSgxXzAwMCwgNTAwLCAxXzAwMCwgNTAwLCB3YWxsZXRfMSksXG4gICAgICAgIF0pXG4gICAgXG4gICAgICAgIGxldCBhc3NldHMgPSBjaGFpbi5nZXRBc3NldHNNYXBzKCkuYXNzZXRzXG5cbiAgICAgICAgLy8gdG9rZW5JbiwgdG9rZW5PdXQsIG1heEluLCBvdXRcbiAgICAgICAgLy8gTk9URTogZGl2aXNpb24gYnkgemVybyBlcnJvciB3aGVuIHN3YXBwaW5nIG91dCBhbGxcbiAgICAgICAgYmxvY2sgPSBjaGFpbi5taW5lQmxvY2soW1xuICAgICAgICAgIHN3YXBUb2tlbnNGb3JFeGFjdFRva2VucygneCcsICd5JywgMV8wMDAsIDEwLCB3YWxsZXRfMiksXG4gICAgICAgIF0pXG5cbiAgICAgICAgLy8gVE9ETzogY2hlY2sgd3JvbmcgdG9rZW4tMC90b2tlbi0xXG4gICAgICAgIGFzc2V0cyA9IGNoYWluLmdldEFzc2V0c01hcHMoKS5hc3NldHNcblxuICAgICAgICBibG9jay5yZWNlaXB0c1swXS5yZXN1bHQuZXhwZWN0RXJyKCkuZXhwZWN0VWludChlcnJfc3dhcF9wb3N0Y29uZGl0aW9ucylcbiAgICB9XG59KVxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBLFNBQVMsUUFBUSxFQUFFLEVBQUUsRUFBa0IsS0FBSyxRQUFvQiw4Q0FBOEMsQ0FBQztBQUMvRyxTQUFTLFlBQVksUUFBUSxpREFBaUQsQ0FBQztBQUMvRSxTQUFTLFFBQVEsRUFBRSxTQUFTLEVBQUUsTUFBTSxRQUFRLGVBQWUsQ0FBQztBQUM1RCxTQUNFLFNBQVMsRUFDVCxjQUFjLEVBSWQsWUFBWSxFQUNaLFlBQVksUUFDUCxXQUFXLENBQUM7QUFJbkIsTUFBTSx1QkFBdUIsR0FBSyxHQUFHO0FBRXJDLE1BQU0sd0JBQXdCLEdBQUksR0FBRztBQUNyQyxNQUFNLHlCQUF5QixHQUFHLEdBQUc7QUFFckMsTUFBTSxFQUNKLElBQUksQ0FBQSxFQUNKLE9BQU8sQ0FBQSxFQUNQLE9B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